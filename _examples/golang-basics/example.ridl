webrpc = v1             # version of webrpc schema format (ridl or json)

name = example          # name if your backend app
version = v0.0.1        # version of your app

enum Kind: uint32
  - USER = 1
  - ADMIN = 2

message User
  - id: uint64
  - username: string
  - role: Kind
  - meta: map<string,any>
  - createdAt?: timestamp
    + json = created_at,omitempty
    + go.tag.db = created_at

#message Message
#  - hash: string
#  - seq: uint64
#  - msg: string
#  - createdAt?: timestamp


message ChatMsg
  - channel: string
  - from: User
  - msg: string


#message ChatRequest
#  - channel: string
#  - from: User
#  - msg: string
#
#message ChatResponse
#  - 
#

# all methods available over http and websocket

service ExampleService
  - Ping() => (status: bool)
  - GetUser(userID: uint64) => (user: User)

  - Auth(t: string) => (status: bool)

  - Chat(msg: stream ChatMsg) => (msg: stream ChatMsg)
  #- Chat(msg: stream ChatRequest) => (msg: stream ChatResponse)
  #- Challenge(msg: stream ChallengeRequest) => (msg: stream ChallengeResponse)


  ##--

  # client sends a message to the server
  #- ChatSendMsg(msg: stream ChatMsg)                 # client ---------> server 
  #- ChatRecvMsg() => (msg: stream ChatMsg)           # client <--------- server

  #- ChallengeRecvMsg() => (msg: stream ChallengeMsg) # client <--------- server


  # the issue with this syntax is we take multiple args..
  #- Chat(sendMsg: stream ChatMsg) => (recvMsg: stream ChatMsg)

  #so, prob should be ..
  # - stream Chat(sendMsg: ChatMsg) => stream (recvMsg: ChatMsg)

  # or.. for all combinations..
  # - Chat(sendMsg: ChatMsg) <=> (recvMsg: ChatMsg)
  # - Chat(clientMsg: ChatMsg) => ()
  # - Chat() <= (serverMsg: ChatMsg)
  # - Chat() streams (serverMsg: ChatMsg)

  # and rpc could be ..
  # - Chat(senMsg: ChatMsg) returns (recvMsg: ChatMsg)
  # - Chat(senMsg: ChatMsg) -- (recvMsg: ChatMsg)
  
