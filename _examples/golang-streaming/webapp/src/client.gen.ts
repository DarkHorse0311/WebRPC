/* tslint:disable */
// hello-webrpc v1.0.0 87ce8159bce3ad056518dfb1f1877b1a1012b34d
// --
// This file has been generated by https://github.com/webrpc/webrpc using gen/typescript
// Do not edit by hand. Update your webrpc schema and re-generate.

// WebRPC description and code-gen version
export const WebRPCVersion = "v1"

// Schema version of your RIDL schema
export const WebRPCSchemaVersion = "v1.0.0"

// Schema hash generated from your RIDL schema
export const WebRPCSchemaHash = "87ce8159bce3ad056518dfb1f1877b1a1012b34d"


// import { ReadableStream } from "web-streams-polyfill/ponyfill"


//
// Types
//
export enum Kind {
  USER = 'USER',
  ADMIN = 'ADMIN'
}

export interface User {
  id: number
  USERNAME: string
  role: Kind
  meta: {[key: string]: any}
  created_at?: string
}

export interface Page {
  num: number
}

export interface ExampleService {
  ping(headers?: object): Promise<PingReturn>
  getUser(args: GetUserArgs, headers?: object): Promise<GetUserReturn>
  download(args: DownloadArgs, headers?: object): Promise<DownloadStream>
}

export interface PingArgs {
}

export interface PingReturn {
}

export interface GetUserArgs {
  id: number
}

export interface GetUserReturn {
  user: User  
}

export interface DownloadArgs {
  file: string
}

export interface DownloadReturn {
  base64: string  
}

export interface DownloadStream {
  open(args?: DownloadArgs, headers?: object): Promise<boolean|WebRPCError> // hmmpf..
  close(): void
  // onopen(handler: () => void): void
  onclose(handler: (err?: WebRPCError) => void): void
  ondata(handler: (data: DownloadReturn) => void): void
}

class StreamClient<TArgs,TReturn> {
  private handlers: string
  private ondataListeners: Array<(data: TReturn) => void>
  private oncloseListeners: Array<(err?: WebRPCError) => void>
  // private signalController: AbortController

  // readyState ? opened, closed, closed-lost

  constructor(
    private fetch: Fetch,
    private url: string,
    private args: TArgs | object,
    private headers?: object
  ) {
    this.oncloseListeners = []
    this.ondataListeners = []
    // this.signalController = new AbortController()
  }

  open = (args?: TArgs | object, headers?: object): Promise<boolean|WebRPCError> => {
    console.log('open() top')

    // Check if browser supports ReadableStream api. A polyfill like web-streams-polyfill
    // may be required for older browsers.
    // @ts-ignore
    // if (typeof ReadableStream == 'undefined') {
    //   throw new Error(`browser does not support ReadableStreams`)
    // }

    // Check if this.fetch supports streaming response bodies. A polyfill like whatwg-fetch
    // combined with web-streams-polyfill may be required for older browsers.
    // if (this.fetch.polyfill)
    // TODO ...
    // ..

    // TODO: try this with node.........
    const that = this // hehe..?


    return new Promise<boolean>((resolve) => {
      // TODO: review this call, either something or nothing..

      this.fetch(
        this.url, 
        {
          ...createHTTPRequest((args || this.args) as object, headers || this.headers)//,
          // signal: this.signalController.signal
        }
      ).then(resp => {

        // hmm, perhaps setup reader on "this".. we could..
        // then we'd have .read(), or make it private...

        this.read(resp)
        resolve(true) // TODO ..
      }).catch(err => {
        console.log(err)
      })
    })
  }

  read = async (resp: Response) => {
    console.log('read me..')

    // const source = new ReadableStream(resp.body as any)
    const source = resp.body!

    console.log('wtfffffffffffffffff...?', source)

    const reader = source.getReader()

    var count = 0

    const stream = () => {
      return reader.read().then(result => {
        console.log('payload:', result)
        // const payload = decoder.decode(result.value || new Uint8Array, { stream: !result.done })
        // console.log('got:', payload)

        // @ts-ignore
        this.emitData({ data: { base64: JSON.stringify(result) } })

        count++

        if (count == 3) {
          reader.cancel()
          return
        }

        if (result.done) {
          // resolve(true)
          // return true
          return
        }
        stream()
      })
    }
    stream()

  }

  close = () => {
    // instead, this.reader.cancel() // .. thank goodness..
    // this.signalController.abort()
  }

  // TODO, onopen ?

  ondata = (handler: (data: TReturn) => void) => {
    this.ondataListeners.push(handler)
  }

  onclose = (handler: (err?: WebRPCError) => void) => {
    this.oncloseListeners.push(handler)
  }

  private emitData = (data: TReturn) => {
    for (var i = 0; i < this.oncloseListeners.length; i++) {
      this.ondataListeners[i](data)
    }
  }

  private emitClose = async () => {

  }
}

//
// Client
//
export class ExampleService implements ExampleService {
  private hostname: string
  private fetch: Fetch
  private path = '/rpc/ExampleService/'

  constructor(hostname: string, fetch: Fetch) {
    this.hostname = hostname
    this.fetch = fetch
  }

  private url(name: string): string {
    return this.hostname + this.path + name
  }

  // TODO: idea for returning error as value... maybe, maybe not?
  // blah = (headers?: object): Promise<PingReturn|WebRPCError> => {
  //   return new Promise<PingReturn>((resolve, reject) => {
  //     resolve({})
  //   })
  // }

  ping = (headers?: object): Promise<PingReturn> => {
    return this.fetch(
      this.url('Ping'),
      createHTTPRequest({}, headers)
      ).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          // status: <boolean>(_data.status)
        }
      })
    })
  }
  
  getUser = (args: GetUserArgs, headers?: object): Promise<GetUserReturn> => {
    return this.fetch(
      this.url('GetUser'),
      createHTTPRequest(args, headers)).then((resp) => {
      return buildResponse(resp).then(_data => {
        return {
          user: <User>(_data.user)
        }
      })
    })
  }
  
  download = async (args: DownloadArgs, headers?: object): Promise<DownloadStream> => {
    const stream = new StreamClient<DownloadArgs, DownloadReturn>(this.fetch, this.url('Download'), args, headers)
    // const stream = new StreamReader(this.fetch, this.url('Download'), args, headers)
    await stream.open() // to be or not to be....?
    return stream
  }
  
}

export interface WebRPCError extends Error {
  code: string
  message: string
}

const createHTTPRequest = (body: object = {}, headers: object = {}): object => {
  return {
    method: 'POST',
    headers: { ...headers, 'Content-Type': 'application/json', 'Accept': '*/*' },
    body: JSON.stringify(body || {})
  }
}

const buildResponse = (res: Response): Promise<any> => {
  return res.text().then(text => {
    let data
    try {
      data = JSON.parse(text)
    } catch(err) {
      throw { code: 'unknown', message: `client error, expecting JSON object but got: '${text}'` } as WebRPCError
    }
    if (!res.ok) {
      throw data as WebRPCError // webrpc error response
    }
    return data
  })
}

export type Fetch = (input: RequestInfo, init?: RequestInit) => Promise<Response>
