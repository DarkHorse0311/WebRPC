/* tslint:disable */
// hello-webrpc v1.0.0 87ce8159bce3ad056518dfb1f1877b1a1012b34d
// --
// This file has been generated by https://github.com/webrpc/webrpc using gen/typescript
// Do not edit by hand. Update your webrpc schema and re-generate.

// WebRPC description and code-gen version
export const WebRPCVersion = "v1"

// Schema version of your RIDL schema
export const WebRPCSchemaVersion = "v1.0.0"

// Schema hash generated from your RIDL schema
export const WebRPCSchemaHash = "87ce8159bce3ad056518dfb1f1877b1a1012b34d"



//
// Types
//
export enum Kind {
  USER = 'USER',
  ADMIN = 'ADMIN'
}

export interface User {
  id: number
  USERNAME: string
  role: Kind
  meta: {[key: string]: any}
  created_at?: string
}

export interface Page {
  num: number
}

export interface ExampleService {
  ping(headers?: object): Promise<PingReturn>
  getUser(args: GetUserArgs, headers?: object): Promise<GetUserReturn>
  download(args: DownloadArgs, headers?: object): Promise<DownloadStream>
}

export interface PingArgs {
}

export interface PingReturn {
}

export interface GetUserArgs {
  id: number
}

export interface GetUserReturn {
  user: User  
}

export interface DownloadArgs {
  file: string
}

export interface DownloadReturn {
  base64: string  
}

export interface DownloadStream {
  open(args?: DownloadArgs, headers?: object): Promise<boolean|WebRPCError> // hmmpf..
  close(): void
  // onopen(handler: () => void): void
  onclose(handler: (err?: WebRPCError) => void): void
  ondata(handler: (data: DownloadReturn) => void): void
}


class StreamClient<TArgs,TReturn> {
  private handlers: string
  private ondataListeners: Array<(data: TReturn) => void>
  private oncloseListeners: Array<(err?: WebRPCError) => void>

  // readyState ? opened, closed, closed-lost

  constructor(
    private fetch: Fetch,
    private url: string,
    private args: TArgs | object,
    private headers?: object
  ) {
    this.oncloseListeners = []
    this.ondataListeners = []
  }

  open = (args?: TArgs | object, headers?: object): Promise<boolean|WebRPCError> => {
    console.log('open() top')

    return new Promise<boolean>((resolve) => {
      // TODO: review this call, either something or nothing..

      this.fetch(
        this.url, 
        {
          ...createHTTPRequest((args || this.args) as object, headers || this.headers)
        }
      ).then(resp => {

        // hmm, perhaps setup reader on "this".. we could..
        // then we'd have .read(), or make it private...

        this.read(resp)
        resolve(true) // TODO ..
      }).catch(err => {
        console.log(err)
      })
    })
  }

  read = async (resp: Response) => {
    console.log('read()')

    const el = document.getElementById('log')?.parentNode

    // @ts-ignore
    el?.textContent += "test"


    const reader = resp.body!.getReader()

    const decoder = new ChunkDecoder()


    var count = 0

    const stream = () => {
      return reader.read().then(result => {
        if (result.done) {
          // do we get final value or done first..? I think .done ..
          return
        }

        decoder.push(result.value).then((chunks) => {
          if (chunks.length > 0) {
            console.log('chunk:', chunks)
          }
        })

        //   // @ts-ignore
        //   // el.textContent += chunk
        // }

        // const chunkString = Utf8ArrayToStr(result.value)
        // console.log('chunk:', chunkString)

        // @ts-ignore
        // this.emitData({ data: { base64: JSON.stringify(result) } })

        // count++

        // if (count == 3) {
        //   console.log('cancelling stream..')
        //   reader.cancel()
        //   return
        // }

        if (result.done) {
          // resolve(true)
          // return true
          return
        }
        stream()
      })
    }
    stream()

  }

  close = () => {
    // instead, this.reader.cancel()
  }

  // TODO, onopen ?

  ondata = (handler: (data: TReturn) => void) => {
    this.ondataListeners.push(handler)
  }

  onclose = (handler: (err?: WebRPCError) => void) => {
    this.oncloseListeners.push(handler)
  }

  private emitData = (data: TReturn) => {
    for (var i = 0; i < this.oncloseListeners.length; i++) {
      this.ondataListeners[i](data)
    }
  }

  private emitClose = async () => {

  }
}

class ChunkDecoder {
  private decoded: string[] = []
  private size: number = -1
  private value: number[] = []
  private state: number = 0 // 0=size, 1=reading data, 2=term

  push(bytes: Uint8Array): Promise<string[]> {
    this.decoded.length = 0
    return new Promise<string[]>((resolve, reject) => {
      let i = 0, c = -1, l = -1
      const v = this.value

      while (i < bytes.length) {
        c = bytes[i]
        if (v.length > 0) {
          l = v[v.length-1]
        }

        switch (this.state) {
          case 0: // new chunk
            if (l == 13 && c == 10) {
              this.size = parseInt("0x"+this.utf8ArrayToStr(v.slice(0,v.length-1)))
              if (this.size == 0) {
                this.size = -1
                this.state = 3
              } else {
                this.state = 1
              }
              v.length = 0
            } else {
              v.push(c)
            }
            break

          case 1: // reading data
            v.push(c)
            if (v.length == this.size) {
              this.state = 2
            }
            break

          case 2: // reading crlf
            if (v.length > this.size+2) {
              reject('chunk invalid')
            }

            // lets read off crlf, then resolve
            v.push(c)
            if (l == 13 && c == 10) {
              const value = this.utf8ArrayToStr(v.splice(0,v.length-2))
              v.length = 0
              this.state = 0
              this.decoded.push(value)
            }
            break

          case 3: // done
            // console.log('STATE 3, TODO...')
            break
        }
        
        i++
      }

      resolve(this.decoded)
    })
  }

  utf8ArrayToStr(bytes: Uint8Array | number[]): string {
    let str = '', i = 0, len = bytes.length, c = 0, char2 = 0, char3 = 0
    while(i < len) {
      c = bytes[i++]
      switch(c >> 4) { 
        case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7:
          // 0xxxxxxx
          str += String.fromCharCode(c)
          break
        case 12: case 13:
          // 110x xxxx   10xx xxxx
          char2 = bytes[i++]
          str += String.fromCharCode(((c & 0x1F) << 6) | (char2 & 0x3F))
          break
        case 14:
          // 1110 xxxx  10xx xxxx  10xx xxxx
          char2 = bytes[i++]
          char3 = bytes[i++]
          str += String.fromCharCode(
            ((c & 0x0F) << 12) | ((char2 & 0x3F) << 6) | ((char3 & 0x3F) << 0)
          )
          break
      }
    }
    return str
  }
}

//
// Client
//
export class ExampleService implements ExampleService {
  private hostname: string
  private fetch: Fetch
  private path = '/rpc/ExampleService/'

  constructor(hostname: string, fetch: Fetch) {
    this.hostname = hostname
    this.fetch = fetch
  }

  private url(name: string): string {
    return this.hostname + this.path + name
  }

  // TODO: idea for returning error as value... maybe, maybe not?
  // blah = (headers?: object): Promise<PingReturn|WebRPCError> => {
  //   return new Promise<PingReturn>((resolve, reject) => {
  //     resolve({})
  //   })
  // }

  ping = (headers?: object): Promise<PingReturn> => {
    return this.fetch(
      this.url('Ping'),
      createHTTPRequest({}, headers)
      ).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          // status: <boolean>(_data.status)
        }
      })
    })
  }
  
  getUser = (args: GetUserArgs, headers?: object): Promise<GetUserReturn> => {
    return this.fetch(
      this.url('GetUser'),
      createHTTPRequest(args, headers)).then((resp) => {
      return buildResponse(resp).then(_data => {
        return {
          user: <User>(_data.user)
        }
      })
    })
  }
  
  download = async (args: DownloadArgs, headers?: object): Promise<DownloadStream> => {
    const stream = new StreamClient<DownloadArgs, DownloadReturn>(this.fetch, this.url('Download'), args, headers)
    // const stream = new StreamReader(this.fetch, this.url('Download'), args, headers)
    await stream.open() // to be or not to be....?
    return stream
  }
  
}

export interface WebRPCError extends Error {
  code: string
  message: string
}

const createHTTPRequest = (body: object = {}, headers: object = {}): object => {
  return {
    method: 'POST',
    headers: { ...headers, 'Content-Type': 'application/json', 'Accept': '*/*' },
    body: JSON.stringify(body || {})
  }
}

const buildResponse = (res: Response): Promise<any> => {
  return res.text().then(text => {
    let data
    try {
      data = JSON.parse(text)
    } catch(err) {
      throw { code: 'unknown', message: `client error, expecting JSON object but got: '${text}'` } as WebRPCError
    }
    if (!res.ok) {
      throw data as WebRPCError // webrpc error response
    }
    return data
  })
}

export type Fetch = (input: RequestInfo, init?: RequestInit) => Promise<Response>
