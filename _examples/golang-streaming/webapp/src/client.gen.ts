/* tslint:disable */
// hello-webrpc v1.0.0 87ce8159bce3ad056518dfb1f1877b1a1012b34d
// --
// This file has been generated by https://github.com/webrpc/webrpc using gen/typescript
// Do not edit by hand. Update your webrpc schema and re-generate.

// WebRPC description and code-gen version
export const WebRPCVersion = "v1"

// Schema version of your RIDL schema
export const WebRPCSchemaVersion = "v1.0.0"

// Schema hash generated from your RIDL schema
export const WebRPCSchemaHash = "87ce8159bce3ad056518dfb1f1877b1a1012b34d"



//
// Types
//
export enum Kind {
  USER = 'USER',
  ADMIN = 'ADMIN'
}

export interface User {
  id: number
  USERNAME: string
  role: Kind
  meta: {[key: string]: any}
  created_at?: string
}

export interface Page {
  num: number
}

export interface ExampleService {
  ping(headers?: object): Promise<PingReturn>
  getUser(args: GetUserArgs, headers?: object): Promise<GetUserReturn>
  download(args: DownloadArgs, headers?: object): Promise<DownloadStream>
}

export interface PingArgs {
}

export interface PingReturn {
}

export interface GetUserArgs {
  id: number
}

export interface GetUserReturn {
  user: User  
}

export interface DownloadArgs {
  file: string
}

export interface DownloadReturn {
  base64: string  
}

export interface DownloadStream {
  open(args?: DownloadArgs, headers?: object): Promise<boolean|WebRPCError> // hmmpf..
  close(): void
  // onopen(handler: () => void): void
  onclose(handler: (err?: WebRPCError) => void): void
  ondata(handler: (data: DownloadReturn) => void): void
}


class StreamClient<TArgs,TReturn> {
  private handlers: string
  private ondataListeners: Array<(data: TReturn) => void>
  private oncloseListeners: Array<(err?: WebRPCError) => void>
  private signal: AbortController

  // readyState ? opened, closed, closed-lost

  constructor(
    private fetch: Fetch,
    private url: string,
    private args: TArgs | object,
    private headers?: object
  ) {
    this.oncloseListeners = []
    this.ondataListeners = []
  }

  open = (args?: TArgs | object, headers?: object): Promise<boolean|WebRPCError> => {
    console.log('open() top')

    return new Promise<boolean>((resolve) => {
      // TODO: review this call, either something or nothing..

      this.signal = new AbortController()

      this.fetch(
        this.url, 
        {
          ...createHTTPRequest((args || this.args) as object, headers || this.headers),
          signal: this.signal.signal
        }
      ).then(resp => {

        // hmm, perhaps setup reader on "this".. we could..
        // then we'd have .read(), or make it private...

        this.read(resp)
        resolve(true) // TODO ..
      }).catch(err => {
        console.log(err)
      })
    })
  }

  read = async (resp: Response) => {
    console.log('read me..')

    // TODO: test this with build on other projects..

    let count = 0

    try {

      // @ts-ignore
      for await (const chunk of resp.body) {

        count++
        if (count == 5) {
          this.close()
        }

        const chunkString = Utf8ArrayToStr(chunk)

        // TODO: catch, and return {} ..
        const payload = JSON.parse(chunkString.slice(chunkString.indexOf("\r\n")+2))

        console.log('JSON-PAYLOAD:', payload)


        // @ts-ignore
        // this.emitData({ data: { base64: JSON.stringify(chunk) } })

      }

    } catch(err) {
      // TODO: catch abort errors, and do nothing..
      console.log('read error.......', err)
    }
  }

  close = () => {
    // instead, this.reader.cancel() // .. thank goodness..
    // this.signalController.abort()
    try {
      this.signal.abort()
    } catch (err) {

    }
  }

  // TODO, onopen ?

  ondata = (handler: (data: TReturn) => void) => {
    this.ondataListeners.push(handler)
  }

  onclose = (handler: (err?: WebRPCError) => void) => {
    this.oncloseListeners.push(handler)
  }

  private emitData = (data: TReturn) => {
    for (var i = 0; i < this.oncloseListeners.length; i++) {
      this.ondataListeners[i](data)
    }
  }

  private emitClose = async () => {

  }
}

//
// Client
//
export class ExampleService implements ExampleService {
  private hostname: string
  private fetch: Fetch
  private path = '/rpc/ExampleService/'

  constructor(hostname: string, fetch: Fetch) {
    this.hostname = hostname
    this.fetch = fetch
  }

  private url(name: string): string {
    return this.hostname + this.path + name
  }

  // TODO: idea for returning error as value... maybe, maybe not?
  // blah = (headers?: object): Promise<PingReturn|WebRPCError> => {
  //   return new Promise<PingReturn>((resolve, reject) => {
  //     resolve({})
  //   })
  // }

  ping = (headers?: object): Promise<PingReturn> => {
    return this.fetch(
      this.url('Ping'),
      createHTTPRequest({}, headers)
      ).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          // status: <boolean>(_data.status)
        }
      })
    })
  }
  
  getUser = (args: GetUserArgs, headers?: object): Promise<GetUserReturn> => {
    return this.fetch(
      this.url('GetUser'),
      createHTTPRequest(args, headers)).then((resp) => {
      return buildResponse(resp).then(_data => {
        return {
          user: <User>(_data.user)
        }
      })
    })
  }
  
  download = async (args: DownloadArgs, headers?: object): Promise<DownloadStream> => {
    const stream = new StreamClient<DownloadArgs, DownloadReturn>(this.fetch, this.url('Download'), args, headers)
    // const stream = new StreamReader(this.fetch, this.url('Download'), args, headers)
    await stream.open() // to be or not to be....?
    return stream
  }
  
}

export interface WebRPCError extends Error {
  code: string
  message: string
}

const createHTTPRequest = (body: object = {}, headers: object = {}): object => {
  return {
    method: 'POST',
    headers: { ...headers, 'Content-Type': 'application/json', 'Accept': '*/*' },
    body: JSON.stringify(body || {})
  }
}

const buildResponse = (res: Response): Promise<any> => {
  return res.text().then(text => {
    let data
    try {
      data = JSON.parse(text)
    } catch(err) {
      throw { code: 'unknown', message: `client error, expecting JSON object but got: '${text}'` } as WebRPCError
    }
    if (!res.ok) {
      throw data as WebRPCError // webrpc error response
    }
    return data
  })
}

export type Fetch = (input: RequestInfo, init?: RequestInit) => Promise<Response>


//
// Compatibility layer for node and web platforms
//

// for node
// install `node-fetch` and `abort-controller` packages

// for web
if (typeof ReadableStream != 'undefined') {
  if (!ReadableStream.prototype[Symbol.asyncIterator]) {
    ReadableStream.prototype[Symbol.asyncIterator] = async function* () {
      let value
      const reader = this.getReader()
      while (1) {
        const r = await reader.read()
        if (r.done) {
          return value
        }
        yield r.value
      }
    }
  }
}

export function Utf8ArrayToStr(bytes: Uint8Array): string {
  let str = '', i = 0, len = bytes.length, c = 0, char2 = 0, char3 = 0
  while(i < len) {
    c = bytes[i++]
    switch(c >> 4) { 
      case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7:
        // 0xxxxxxx
        str += String.fromCharCode(c)
        break
      case 12: case 13:
        // 110x xxxx   10xx xxxx
        char2 = bytes[i++]
        str += String.fromCharCode(((c & 0x1F) << 6) | (char2 & 0x3F))
        break
      case 14:
        // 1110 xxxx  10xx xxxx  10xx xxxx
        char2 = bytes[i++]
        char3 = bytes[i++]
        str += String.fromCharCode(((c & 0x0F) << 12) |
                      ((char2 & 0x3F) << 6) |
                      ((char3 & 0x3F) << 0))
        break
    }
  }
  return str
}
